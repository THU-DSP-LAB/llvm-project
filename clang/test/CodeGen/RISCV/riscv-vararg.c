// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -triple riscv32 -S -emit-llvm -mllvm -riscv-common-data-layout \
// RUN: %s -o - | FileCheck --check-prefix=CHECK-RV32 %s

// CHECK-RV32-LABEL: @test_vararg(
// CHECK-RV32-NEXT:  entry:
// CHECK-RV32-NEXT:    [[FMT_ADDR:%.*]] = alloca ptr, align 4
// CHECK-RV32-NEXT:    [[VA:%.*]] = alloca ptr, align 4
// CHECK-RV32-NEXT:    [[RETVAL1:%.*]] = alloca i32, align 4
// CHECK-RV32-NEXT:    store ptr [[FMT:%.*]], ptr [[FMT_ADDR]], align 4
// CHECK-RV32-NEXT:    call void @llvm.va_start(ptr [[VA]])
// CHECK-RV32-NEXT:    [[ARGP_CUR:%.*]] = load ptr, ptr [[VA]], align 4
// CHECK-RV32-NEXT:    [[ARGP_NEXT:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR]], i32 4
// CHECK-RV32-NEXT:    store ptr [[ARGP_NEXT]], ptr [[VA]], align 4
// CHECK-RV32-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARGP_CUR]], align 4
// CHECK-RV32-NEXT:    store i32 [[TMP0]], ptr [[RETVAL1]], align 4
// CHECK-RV32-NEXT:    call void @llvm.va_end(ptr [[VA]])
// CHECK-RV32-NEXT:    [[TMP1:%.*]] = load i32, ptr [[RETVAL1]], align 4
// CHECK-RV32-NEXT:    ret i32 [[TMP1]]
//
int test_vararg(char *fmt,...) {
  __builtin_va_list va;
  __builtin_va_start(va, fmt);
  int retval = __builtin_va_arg(va, int);
  __builtin_va_end(va);
  return retval;
}
